---
name: Dungeoneer
year: 2024
description: Überprüfe, welche Gegenstände einem Charakter in Final Fantasy XIV fehlen.
technologies:
  ["Next.js", "Cheerio", "Supabase", "Redis", "PostgreSQL", "Vercel"]
headerImage:
  src: "/portfolio/projects/dungeoneer.jpg"
  alt: "Screenshot der Dungeoneer-Website"
cardImage:
  src: "/portfolio/cards/dungeoneer.png"
  alt: "Screenshot der Dungeoneer-Website auf Mobilgeräten"
liveWebsite: "https://xiv-dungeoneer.vercel.app"
repository: "https://github.com/gomisroca/dungeoneer"
---

<strong>Dungeoneer</strong> ist ein Projekt, das dir dabei hilft, zu verfolgen,
welche Sammelobjekte dir in Dungeons, Prüfungen oder Raids in Final Fantasy XIV
fehlen. Sie können Ihre Sammlung entweder lokal speichern oder sich anmelden und
sie in Ihrem Konto speichern.

<hr />

<h1 class="text-2xl">Technologien und Tools</h1>
<ul>
  <li>
    <h6 className="text-lg font-semibold">Next.js</h6>
    <p>
      Next.js wurde aufgrund seiner Einfachheit, Benutzerfreundlichkeit und
      branchenweiten Akzeptanz als Framework für das Projekt ausgewählt. Darüber
      hinaus wussten wir, dass große Teile des Projekts von serverseitigem
      Rendering profitieren könnten, was Next.js hervorragend beherrscht.
    </p>
    <p>
      Wir entschieden uns für den moderneren Next.js App Router und wechselten
      2025 von tRPC zu einer Kombination aus Serveraktionen und API-Routen.
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">Redis</h6>
    <p>
      Das Projekt enthält große, häufig abgerufene Datensätze, wie z. B.
      Artikel- oder Instanzlisten. Daher haben wir Redis integriert, um die
      Leistung durch Zwischenspeichern zu optimieren. Dies reduzierte die
      Datenbanklast und verbesserte die Antwortzeiten bei leseintensiven
      Vorgängen deutlich.
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">Auth.js</h6>
    <p>
      Eine der Hauptfunktionen des Projekts ist die Möglichkeit, sich anzumelden
      und die Sammlung in Ihrem Konto zu speichern. Dafür haben wir Auth.js
      verwendet, das eine einfache und sichere Methode zur
      Benutzerauthentifizierung und -autorisierung bietet.
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">Cheerio</h6>
    <p>
      Das Scrappen von „The Lodestone“, der Website von Final Fantasy XIV, nach
      Informationen ist eine häufige Aufgabe im Projekt. Wir müssen oft nach
      Charakteren oder nach spezifischen Informationen zu deren Sammlung suchen.
      Dafür haben wir Cheerio verwendet, eine schnelle und flexible
      HTML-Parsing-Bibliothek, mit der wir die Website problemlos scrapen
      konnten.
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">TailwindCSS + Motion</h6>
    <p>
      Tailwind bot uns eine schnelle und zuverlässige Möglichkeit, das Projekt
      zu gestalten. Wir wollten jedoch einigen Elementen einige Animationen
      hinzufügen und verwendeten dafür Motion (ehemals Framer Motion).
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">Supabase</h6>
    <p>
      Supabase ist eine Cloud-basierte Datenbank, die eine robuste und
      skalierbare Lösung zum Speichern und Abrufen von Daten bietet. Wir
      verwendeten sie zum Speichern der In-Game-Daten, der Sammlung und
      Informationen des Benutzers sowie zur Handhabung der
      Benutzerauthentifizierung. Darüber hinaus verwenden wir Supabase Buckets
      zum Speichern der Bilder der Elemente.
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">Vercel</h6>
    <p>
      Da wir uns für Next.js entschieden hatten, schien die Bereitstellung auf
      Vercel die beste und effizienteste Option zu sein. Wir nutzten Vercels
      Analytics und Speed Insights, um einen reibungslosen Projektablauf
      sicherzustellen.
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">
      tRPC <span className="text-sm text-zinc-500 uppercase">Veraltet</span>
    </h6>
    <p>
      Wir erwarteten für das Projekt viele API-Aufrufe und komplexe Datentypen.
      Daher entschieden wir uns für tRPC für die Kommunikation zwischen Client
      und Server, um Typsicherheit und eine schnellere, sicherere Entwicklung zu
      gewährleisten.
    </p>
    <p>
      Im Jahr 2025 haben wir tRPC zugunsten einer Kombination aus Serveraktionen
      und API-Routen abgeschafft. Dabei nutzen wir native Next.js-Funktionen,
      Edge-Funktionen und Redis-basiertes Caching für verbesserte Leistung und
      Wartbarkeit.
    </p>
  </li>
</ul>

<hr />

<h1 class="text-2xl">Rollen und Verantwortlichkeiten</h1>
Dieses Projekt wurde 2022 erstmals von einem Team aus drei Entwicklern
entwickelt. Es wurde jedoch schließlich aufgegeben und ich übernahm das Projekt
2024 als alleiniger Entwickler.
<ul>
  <li>
    <h6 className="text-lg font-semibold">UI/UX-Designer</h6>
    <p>
      Entwarf die Benutzeroberfläche und das Benutzererlebnis des Projekts. Ich
      verwendete Figma, um die Designs zu erstellen, und implementierte sie im
      Projekt mit TailwindCSS und Motion.
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">Full-Stack-Entwickler</h6>
    <p>
      Ich implementierte die Funktionalität des Projekts und stellte sicher,
      dass es sicher und skalierbar war. Ich verwendete unter anderem Next.js,
      tRPC, Auth.js und Supabase, um das Projekt zu entwickeln. Später nutzte
      ich Redis zur Optimierung des Datenabrufprozesses, Serveraktionen zur
      Handhabung von Mutationen und Cheerio zum Scrapen des Lodestone.
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">Projektmanager</h6>
    <p>
      Als alleiniger Entwickler war ich für die Gesamtverwaltung und Wartung
      verantwortlich. Ich stellte sicher, dass das Projekt auf Kurs blieb, mit
      einem Fokus auf Kernfunktionen und Fehlerbehebungen, ohne dass Feature
      Creep die Richtung des Projekts verzerrte.
    </p>
  </li>
</ul>

<hr />

<h1 class="text-2xl">Herausforderungen und Lösungen</h1>
<ul>
  <li>
    <h6 className="text-lg font-semibold">Projektüberholung</h6>
    <p>
      Als ich die Rolle des alleinigen Entwicklers übernahm, wusste ich zwei
      Dinge: Das Projekt war noch nicht fertig und die verwendeten Technologien
      waren veraltet. In diesem Anfangszustand verwendete es einen einfachen
      Angular + MongoDB-Stack. Ich entschied mich, Next.js zu verwenden und auf
      PostgreSQL umzusteigen, da diese besser zu den Anforderungen des Projekts
      zu passen schienen.
    </p>
    <p>
      In Bezug auf das Frontend verlief der Wechsel relativ reibungslos. Das
      ursprüngliche Frontend war nicht komplex und es in Next.js zu replizieren
      war relativ unkompliziert. Allerdings musste ich das gesamte Backend von
      Grund auf neu schreiben. Die Datenbank war völlig anders, ebenso wie die
      API und das Authentifizierungssystem.
    </p>
    <p>
      Letztendlich denke ich, dass diese komplette Überarbeitung eine gute
      Entscheidung war, die zu einem robusteren und skalierbareren Projekt mit
      einem schnelleren Entwicklungszyklus geführt hat.
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">UI-Überladen</h6>
    <p>
      Ein Problem, mit dem ich beim Erstellen der UI konfrontiert war, war
      Überladenheit. Es gab zu viele Elemente auf der Seite und das Layout war
      nicht intuitiv. Gleichzeitig wollte ich eine klare Navigationsstruktur
      beibehalten, damit Benutzer leicht finden konnten, wonach sie suchten.
    </p>
    <p>
      Ich beschloss, die UI zu vereinfachen: Das Navigationsmenü sollte aus
      einigen Schaltflächen bestehen, die zu den Hauptabschnitten führen, und
      einem Dropdown-Menü für andere Abschnitte und Optionen wie Anmelden und
      Themenwechsel.
    </p>
    <p>
      Ebenso wurden auch die Artikelkarten vereinfacht. Anstatt im Text
      anzugeben, um welche Art von Artikel es sich handelt oder woher er stammt,
      habe ich mich dazu entschieden, dies durch Symbole darzustellen und die
      Artikeldetails in Dropdown-Menüs anzuzeigen.
    </p>
    <p>
      Obwohl es insgesamt noch Raum für Verbesserungen gibt, bin ich der
      Meinung, dass das aktuelle Design eine gute Balance zwischen
      Funktionalität und visueller Klarheit bietet.
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">Datenabruf und Virtualisierung</h6>
    <p>
      Wie bereits erwähnt, enthält das Projekt große Datensätze, auf die häufig
      zugegriffen wird, wie z. B. Artikel- oder Instanzlisten. Dies kann bei
      unsachgemäßer Handhabung zu Leistungsproblemen und langsamen
      Reaktionszeiten führen.
    </p>
    <p>
      Um dies zu beheben, habe ich zunächst eine scrollbasierte Abrufstrategie
      implementiert, bei der der Benutzer durch die Artikelliste scrollt und die
      Artikel stapelweise abgerufen werden. Dies funktionierte gut, und die
      Daten wurden schnell abgerufen und geladen. Die Leistung verschlechterte
      sich jedoch erheblich, je weiter der Benutzer in der Liste nach unten
      scrollte.
    </p>
    <p>
      Um die Leistung zu verbessern, implementierte ich eine virtualisierte
      Listenkomponente, die nur die sichtbaren Elemente renderte. Dies
      ermöglichte ein reibungsloseres Benutzererlebnis, da der Benutzer nur die
      auf dem Bildschirm sichtbaren Elemente sah und die Daten nur bei Bedarf
      abgerufen wurden.
    </p>
  </li>
  <li>
    <h6 className="text-lg font-semibold">Datenerfassung</h6>
    <p>
      Anfangs war das Projekt auf die Lodestone-Funktionen von XIVAPI
      angewiesen, um nach Charakteren und deren Sammlungen zu suchen. Diese
      wurden jedoch nach XIVAPI v2 veraltet, und die alternativen APIs und
      Bibliotheken waren für die Anforderungen des Projekts nicht mehr geeignet.
    </p>
    <p>
      Der Lodestone ist eine bekanntermaßen schwierig zu scrapende Website. Dies
      war mein erster Versuch, ein so umfangreiches Scraping durchzuführen. Dank
      der Hilfe der Community gelang es mir jedoch, Cheerio zu implementieren,
      um die Website zu scrapen und die benötigten Daten zu extrahieren. Dabei
      habe ich die Lodestone-bezogenen Funktionen, wie die Charaktersuche und
      den Sammlungsabruf, komplett überarbeitet.
    </p>
    <p>
      Das Ergebnis ist ein robusteres und zuverlässigeres System ohne unnötige
      Zwischenhändler oder externe Abhängigkeiten.
    </p>
  </li>
</ul>
